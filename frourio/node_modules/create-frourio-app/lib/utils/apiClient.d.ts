export declare const createApiClient: () => {
    answers: {
        get: (option?: {
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        } | undefined) => Promise<import("aspida").AspidaResponse<Partial<Record<"dir" | "server" | "client" | "building" | "mode" | "target" | "aspida" | "reactHooks" | "pm" | "daemon" | "testing" | "orm" | "db" | "skipDbChecks" | "postgresqlDbHost" | "postgresqlDbPort" | "postgresqlDbUser" | "postgresqlDbPass" | "postgresqlDbName" | "mysqlDbHost" | "mysqlDbPort" | "mysqlDbUser" | "mysqlDbPass" | "mysqlDbName" | "sqliteDbFile" | "ci" | "deployBranch" | "deployServer" | "staticHosting" | "serverless" | "serverSourcePath" | "designatedServer", string>>, import("aspida").BasicHeaders, import("aspida").HttpStatusOk>>;
        $get: (option?: {
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        } | undefined) => Promise<Partial<Record<"dir" | "server" | "client" | "building" | "mode" | "target" | "aspida" | "reactHooks" | "pm" | "daemon" | "testing" | "orm" | "db" | "skipDbChecks" | "postgresqlDbHost" | "postgresqlDbPort" | "postgresqlDbUser" | "postgresqlDbPass" | "postgresqlDbName" | "mysqlDbHost" | "mysqlDbPort" | "mysqlDbUser" | "mysqlDbPass" | "mysqlDbName" | "sqliteDbFile" | "ci" | "deployBranch" | "deployServer" | "staticHosting" | "serverless" | "serverSourcePath" | "designatedServer", string>>>;
        patch: (option: {
            body: Partial<Record<"dir" | "server" | "client" | "building" | "mode" | "target" | "aspida" | "reactHooks" | "pm" | "daemon" | "testing" | "orm" | "db" | "skipDbChecks" | "postgresqlDbHost" | "postgresqlDbPort" | "postgresqlDbUser" | "postgresqlDbPass" | "postgresqlDbName" | "mysqlDbHost" | "mysqlDbPort" | "mysqlDbUser" | "mysqlDbPass" | "mysqlDbName" | "sqliteDbFile" | "ci" | "deployBranch" | "deployServer" | "staticHosting" | "serverless" | "serverSourcePath" | "designatedServer", string>>;
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        }) => Promise<import("aspida").AspidaResponse<void, import("aspida").BasicHeaders, 204>>;
        $patch: (option: {
            body: Partial<Record<"dir" | "server" | "client" | "building" | "mode" | "target" | "aspida" | "reactHooks" | "pm" | "daemon" | "testing" | "orm" | "db" | "skipDbChecks" | "postgresqlDbHost" | "postgresqlDbPort" | "postgresqlDbUser" | "postgresqlDbPass" | "postgresqlDbName" | "mysqlDbHost" | "mysqlDbPort" | "mysqlDbUser" | "mysqlDbPass" | "mysqlDbName" | "sqliteDbFile" | "ci" | "deployBranch" | "deployServer" | "staticHosting" | "serverless" | "serverSourcePath" | "designatedServer", string>>;
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        }) => Promise<void>;
        $path: () => string;
    };
    dbConnection: {
        post: (option: {
            body: Partial<Record<"dir" | "server" | "client" | "building" | "mode" | "target" | "aspida" | "reactHooks" | "pm" | "daemon" | "testing" | "orm" | "db" | "skipDbChecks" | "postgresqlDbHost" | "postgresqlDbPort" | "postgresqlDbUser" | "postgresqlDbPass" | "postgresqlDbName" | "mysqlDbHost" | "mysqlDbPort" | "mysqlDbUser" | "mysqlDbPass" | "mysqlDbName" | "sqliteDbFile" | "ci" | "deployBranch" | "deployServer" | "staticHosting" | "serverless" | "serverSourcePath" | "designatedServer", string>>;
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        }) => Promise<import("aspida").AspidaResponse<{
            enabled: true;
        } | {
            enabled: false;
            err: string;
        }, import("aspida").BasicHeaders, import("aspida").HttpStatusOk>>;
        $post: (option: {
            body: Partial<Record<"dir" | "server" | "client" | "building" | "mode" | "target" | "aspida" | "reactHooks" | "pm" | "daemon" | "testing" | "orm" | "db" | "skipDbChecks" | "postgresqlDbHost" | "postgresqlDbPort" | "postgresqlDbUser" | "postgresqlDbPass" | "postgresqlDbName" | "mysqlDbHost" | "mysqlDbPort" | "mysqlDbUser" | "mysqlDbPass" | "mysqlDbName" | "sqliteDbFile" | "ci" | "deployBranch" | "deployServer" | "staticHosting" | "serverless" | "serverSourcePath" | "designatedServer", string>>;
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        }) => Promise<{
            enabled: true;
        } | {
            enabled: false;
            err: string;
        }>;
        $path: () => string;
    };
    localPath: {
        post: (option: {
            body: {
                path: string;
            };
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        }) => Promise<import("aspida").AspidaResponse<import("../server/api/localPath").LocalPathInfo, import("aspida").BasicHeaders, import("aspida").HttpStatusOk>>;
        $post: (option: {
            body: {
                path: string;
            };
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        }) => Promise<import("../server/api/localPath").LocalPathInfo>;
        $path: () => string;
    };
    status: {
        get: (option?: {
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        } | undefined) => Promise<import("aspida").AspidaResponse<import("../server/api/status").ServerStatus, import("aspida").BasicHeaders, import("aspida").HttpStatusOk>>;
        $get: (option?: {
            config?: import("axios").AxiosRequestConfig<any> | undefined;
        } | undefined) => Promise<import("../server/api/status").ServerStatus>;
        $path: () => string;
    };
};
