import type { AspidaClient, BasicHeaders } from 'aspida';
import type { Methods as Methods0 } from './answers';
import type { Methods as Methods1 } from './dbConnection';
import type { Methods as Methods2 } from './localPath';
declare const api: <T>({ baseURL, fetch }: AspidaClient<T>) => {
    answers: {
        get: (option?: {
            config?: T | undefined;
        } | undefined) => Promise<import("aspida").AspidaResponse<Partial<Record<"dir" | "server" | "client" | "building" | "mode" | "target" | "aspida" | "reactHooks" | "pm" | "daemon" | "testing" | "orm" | "db" | "skipDbChecks" | "postgresqlDbHost" | "postgresqlDbPort" | "postgresqlDbUser" | "postgresqlDbPass" | "postgresqlDbName" | "mysqlDbHost" | "mysqlDbPort" | "mysqlDbUser" | "mysqlDbPass" | "mysqlDbName" | "sqliteDbFile" | "ci" | "deployBranch" | "deployServer" | "staticHosting" | "serverless" | "serverSourcePath" | "designatedServer", string>>, BasicHeaders, import("aspida").HttpStatusOk>>;
        $get: (option?: {
            config?: T | undefined;
        } | undefined) => Promise<Partial<Record<"dir" | "server" | "client" | "building" | "mode" | "target" | "aspida" | "reactHooks" | "pm" | "daemon" | "testing" | "orm" | "db" | "skipDbChecks" | "postgresqlDbHost" | "postgresqlDbPort" | "postgresqlDbUser" | "postgresqlDbPass" | "postgresqlDbName" | "mysqlDbHost" | "mysqlDbPort" | "mysqlDbUser" | "mysqlDbPass" | "mysqlDbName" | "sqliteDbFile" | "ci" | "deployBranch" | "deployServer" | "staticHosting" | "serverless" | "serverSourcePath" | "designatedServer", string>>>;
        patch: (option: {
            body: Methods0['patch']['reqBody'];
            config?: T | undefined;
        }) => Promise<import("aspida").AspidaResponse<void, BasicHeaders, 204>>;
        $patch: (option: {
            body: Methods0['patch']['reqBody'];
            config?: T | undefined;
        }) => Promise<void>;
        $path: () => string;
    };
    dbConnection: {
        post: (option: {
            body: Methods1['post']['reqBody'];
            config?: T | undefined;
        }) => Promise<import("aspida").AspidaResponse<{
            enabled: true;
        } | {
            enabled: false;
            err: string;
        }, BasicHeaders, import("aspida").HttpStatusOk>>;
        $post: (option: {
            body: Methods1['post']['reqBody'];
            config?: T | undefined;
        }) => Promise<{
            enabled: true;
        } | {
            enabled: false;
            err: string;
        }>;
        $path: () => string;
    };
    localPath: {
        post: (option: {
            body: Methods2['post']['reqBody'];
            config?: T | undefined;
        }) => Promise<import("aspida").AspidaResponse<import("./localPath").LocalPathInfo, BasicHeaders, import("aspida").HttpStatusOk>>;
        $post: (option: {
            body: Methods2['post']['reqBody'];
            config?: T | undefined;
        }) => Promise<import("./localPath").LocalPathInfo>;
        $path: () => string;
    };
    status: {
        get: (option?: {
            config?: T | undefined;
        } | undefined) => Promise<import("aspida").AspidaResponse<import("./status").ServerStatus, BasicHeaders, import("aspida").HttpStatusOk>>;
        $get: (option?: {
            config?: T | undefined;
        } | undefined) => Promise<import("./status").ServerStatus>;
        $path: () => string;
    };
};
export declare type ApiInstance = ReturnType<typeof api>;
export default api;
